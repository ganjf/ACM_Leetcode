# 动态规划专题-背包问题

ref: \[背包问题九讲]

​		[github](https://github.com/tianyicui/pack/), [百度文库](https://wenku.baidu.com/view/4d68b68fbceb19e8b8f6bacd.html)

## 1.01背包问题

有N件物品和一个容量为V的背包，让如第 i 件物品耗费的空间是 C<sub>i</sub> ,获得的价值是 W<sub>i</sub> ,求解将哪些物品装入背包可以实现价值最大化。

### 基本思路

问题特点：每个物品只有一件，可以选择放也可以选择不放；

> 每完成一次物品选择相当于背包容量减小，可选择的物品列表减小，即变成了相同需求但是更小规模的问题。

> 状态定义：F\[i][v]表示前 i 件物品放入容量为 v 的背包所能获得的最大价值。

- 对于第 i 件物品，存在两个选择：放或者不放

  - 放：value = F\[i - 1][v - C<sub>i</sub>] + W<sub>i</sub>
  - 不放：value = F\[i - 1][v]
  - **F\[i][v] = max(F\[i - 1][v - C<sub>i</sub>] + W<sub>i</sub> ,  F\[i - 1][v])**

- 时间复杂度：O(VN)

- 空间复杂度：O(VN) / O(V)

  - 使用一维数组F[v]，物品顺序的存储 i 以严格的顺序排列的（i-1 --> i)
  - **以递减的顺序v = V....0，可以保证F[v - C<sub>i</sub>] = F\[i-1][v - C<sub>i</sub>]**

- 问题要求区分初始化：

  - 恰好装满背包
    - F[0] = 0, F[1...V] = -∞
    - 如果要求恰好装满，则只有容量为0的背包可以在什么都不装且价值为0的时候被恰好装满，其余容量均没有合法的解，属未定义状态。
  - 不要求必须装满背包
    - F[0....V] = 0

- ```cpp
  def ZeroOnePack(F,C,W){
      for v = V to C
          F[v] = max(F[v], F[v-C]+W)
  }
  ```

  

## 2.完全背包问题

有N种物品和一个容量为V的背包，每种物品都有无限件可以用。放入第 i 种物品所耗费的空间是C<sub>i</sub> , 得到的价值是W<sub>i</sub> ,求解：将哪些物品装入背包，可使这些物品的耗费的空间总和不超过背包容量，且价值总和最大。（例如，买菜问题）

### 基本思路

- 如果按照01背包问题时的思路，令F[i, v]表示前i种物品恰放入一个容量为v的背包的最大价值，可得状态转移方程为：
  - F\[i][v] = max{F\[i - 1][v - kC<sub>i</sub>] + kW<sub>i</sub> |0 <= kC<sub>i</sub> <=v)

- 问题优化: 任何情况下都可以将价值小耗费高的 j 换成物美价廉的 i ,至少得到的方案不会更差 O(N<sup>2</sup>)。

- 转化为 01背包问题求解

  - 将一个物品拆成多件只能选择0或1件的01背包问题

    - 考虑到第 i 件物品最多选择 V / C<sub>i</sub> 件，于是可以把第 i 个物品转化为 V / C<sub>i</sub> 件价值及费用均相等的物品。

    - （更高效）把第 i 件物品拆成费用为 C<sub>i</sub>2<sup>k</sup> 、价值为 W<sub>i</sub>2<sup>k</sup> 的若干件物品，其中k区便满足 C<sub>i</sub>2<sup>k</sup>  <= V 的**非负整数**。

      > 二进制思想，不管最优策略选几件第 i 种物品，其件数可以表示成若干个2<sup>k</sup>件物品的和。（拆成了 log(V / C<sub>i</sub>) 件）

  - ```cpp
    def CompletePack(F,C,W){
        k := 1
        for C * k <= V
            ZeroOnePack(F, kC, kW)
            k *= 2
    }
    ```

- 不转化为 01 背包问题求解

  - ```cpp
    F[0...v] = 0;
    for i = 1 to N
        for v = Ci to V
            F[v] = max(F[v], F[v - Ci] + Wi)
    ```

  - 每个物品可以选无限件，所以在考虑 "加选一件第 i 个物品" 时，需要一个可能已选入第 i 种物品的子结果F[i, v - Ci].

- ```cpp
  def CompletePack(F,C,W){
      for v = C to V
          F[v] = max(F[v], F[v-C] + W)
  }
  ```

  

## 3.多重背包问题

有N种物品和一个容量为V的背包，第i种物品最多有M<sub>i</sub> 件可用，每件耗费的空间是C<sub>i</sub>  ,价值是W<sub>i</sub> 。求解将哪些物品装入背包可使这些物品的耗费恐怖超过背包容量，且价值总和最大。

### 基本思路

- 基本状态转移方程
  - F\[i][v] = max{F\[i - 1][v - kC<sub>i</sub>] + kW<sub>i</sub> |0 <= kC<sub>i</sub> <=M}
- 转换为01背包问题
  - 2<sup>k</sup>、M-2<sup>k</sup>+1, (M-2<sup>k</sup>+1 > 0)

- ```cp
  def MultiplePack(F,C,W,M){
  	if C*M > V
  		CompletePack(F,C,W)
  		return
  	k := 1
  	while k<M:
  		ZeroOnePack(F, kC,kW)
  		M = M - k
  		k *= 2
  	ZeroOnePack(F, MC, MW)
  }
  ```

## 4.二维费用的背包问题

对于每件物品，具有两种不同的空间损耗，选择这件物品必须同时付出这两种代价。对于每种代价都有一个可付出的最大值（背包容量），问怎么选择物品可以获得最大价值。

### 基本思路

- 令F\[i]\[v][u]表示前 i 件物品付出的两种代价分别为v 和 u时可获得的最大价值，状态转移方程为(01背包问题）：
  - F\[i]\[v][u] = max(F\[i]\[v][u]， F\[i]\[v - Ci][u - Di] + Wi)
  - 01背包问题-逆序（v、u）
  - 完全背包问题-顺序（v、u)
  - 多重背包问题-拆分
- 可以把二维费用看成是一维费用的复整数形式；

## 5.分组的背包问题

有N件物品和一个容量为V的背包，第i件物品的费用是Ci, 价值是Wi。这些物品被划分为K组，每组中的物品互相冲突，最多选择一件，求解，将那些物品装入背包可使得这些物品的费用综合不超过背包容量，且价值最大；

### 基本思路

- 用F\[k][v]来表示前k组物品付出代价为v时的最大价值

- ```cpp
  for k = 1 to K
      for item i in group
          for v = V to Ci
              F[v] = max(F[v], F[v-Ci]+Wi)
  ```

## 6.有依赖的背包问题

物品 i 依赖于物品 j, 表示若选择物品 i, 则必须选择物品 j。为了简化起见，假设没有某个物品既依赖于别的物品，又被别的物品依赖；且没有某件物品同时依赖多个物品。

### 基本思路

- 将每个主件及其附件集合转化为物品组

## 7.背包问题问法的变化

- 输出最优方案

  - 记录下每个状态的最优值是由状态方程的哪一项推出来的

- 输出字典序最小的最优方案

- 求方案总数

  - F[i, v] = sum(F[i-1, v] + F[i, v-Ci])

- 最优方案总数

  - ```cpp
    if F[i, v] = F[i-1, v]
        G[i, v] += G[i-1, v]
    if F[i, v] = F[i, v-Ci] + Wi
        F[i, v] += G[i, v-Ci]
    ```

- 求次优解，K优解
  - F[i, v, k]来表示前 i 个物品中，背包大小为 v 时，第k优解的值。